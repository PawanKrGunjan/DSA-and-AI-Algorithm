import sys

class Solution:
    def merge(self, nums1, m: int, nums2, n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        temp =[]
        i=j=0
        while j<n:
            if temp:
                while temp[0] < nums2[j]:
                    temp.append(nums1[i])
                    nums1[i]=temp.pop(0)
                    if temp[0]==0:
                        break
                    i+=1
            while nums2[j]>nums1[i] and nums1[i]!=0:
                i+=1
            if nums1[i]!=0:
                temp.append(nums1[i])
            nums1[i]=nums2[j]
            j+=1
            i+=1
            #print(nums1,j)
        i=m+n-len(temp)
        while temp and temp[0]!=0:
            nums1[i]=temp.pop(0)
            i+=1

    def removeDuplicates(self, nums) -> int:
        temp =  nums[0]
        n=len(nums)
        j=1
        i=1
        while j<n and i<n:
            while temp ==nums[j]:
                j+=1
                if j==n:
                    return i
            nums[i],nums[j]=nums[j],nums[i]
            temp =nums[i]
            j+=1
            i+=1
        return i

    def rotate(self, nums, k) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        def rotatelist(nums,i,j):
            while i<j:
                nums[i],nums[j]=nums[j],nums[i]
                i+=1
                j-=1
        k =k%n
        rotatelist(nums,n-k,n-1)
        rotatelist(nums,0,n-k-1)
        rotatelist(nums,0,n-1)

    def canJump(self, nums) -> bool:
        n = len(nums)
        if n<=1:
            return True
        max_jumps=0
        for i in range(n):
            next_jumps= i+nums[i]
            for j in range(i,next_jumps):
                jumps=j+nums[j]
                if jumps>=n-1:
                    return True
                max_jumps=max(max_jumps,next_jumps,jumps)
            if next_jumps ==i and max_jumps<=i:
                return False
        return False

    def minimumJumps(self,nums, n):
        #Your code here
        n =len(nums)
        if n <=1:
            return 0
        i=0
        stepcount=0
        while i<n:
            Step= i+nums[i]
            stepcount+=1
            if Step>=n-1:
                return stepcount
            max_step= Step
            temp= nums[Step]
            for j in range(i+1,Step+1):
                if nums[j]>=temp:
                    max_step=j
                    temp=nums[j]
                if j+nums[j]>=n-1:
                    return stepcount+1 
            if i==max_step:
                return -1
            i =max_step

        return stepcount

    def jump(self, nums) -> int:
        n = len(nums)
        
        # Initialize dp array where dp[i] represents the minimum jumps to reach index i
        min_jumps = [sys.maxsize] * n
        min_jumps[0] = 0  # Starting point requires 0 jumps
        
        for current in range(1, n):
            for previous in range(current):
                # Check if we can jump from previous to current index
                if current <= previous + nums[previous] and min_jumps[previous] != sys.maxsize:
                    # Update the minimum jumps needed to reach current index
                    min_jumps[current] = min(min_jumps[current], min_jumps[previous] + 1)
                    break  # No need to check further, as we found a valid jump
        
        return min_jumps[-1]  # Return the minimum jumps to reach the last index
